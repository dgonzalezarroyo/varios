<!DOCTYPE html> <html lang="es"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Intersecci√≥n de Tres Planos - Visualizador 3D</title> <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <style> * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; overflow: hidden; } .container { display: flex; height: 100vh; } .controls { width: 320px; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); padding: 20px; overflow-y: auto; border-right: 1px solid rgba(255, 255, 255, 0.1); } .viewer { flex: 1; position: relative; } h1 { font-size: 1.5em; margin-bottom: 20px; text-align: center; color: #00d4ff; text-shadow: 0 0 10px rgba(0, 212, 255, 0.5); } .plane-group { margin-bottom: 25px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1); } .plane-title { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; } .color-indicator { width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; } .input-group { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 8px; margin-bottom: 15px; align-items: center; } .input-label { font-size: 0.9em; color: #ccc; text-align: center; } input[type="range"] { width: 100%; height: 6px; border-radius: 3px; background: rgba(255, 255, 255, 0.2); outline: none; -webkit-appearance: none; } input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00d4ff; cursor: pointer; box-shadow: 0 0 10px rgba(0, 212, 255, 0.5); } input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #00d4ff; cursor: pointer; border: none; box-shadow: 0 0 10px rgba(0, 212, 255, 0.5); } input[type="number"] { background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; padding: 6px; color: white; font-size: 0.85em; text-align: center; width: 100%; } .equation { font-family: 'Courier New', monospace; background: rgba(255, 255, 255, 0.1); padding: 8px; border-radius: 6px; font-size: 0.85em; text-align: center; margin-top: 10px; } .analysis { background: rgba(0, 0, 0, 0.6); padding: 15px; border-radius: 12px; margin-top: 20px; } .analysis h3 { color: #ff6b6b; margin-bottom: 10px; font-size: 1em; } .analysis p { font-size: 0.9em; line-height: 1.4; color: #ddd; } .controls-bottom { margin-top: 20px; text-align: center; } button { background: linear-gradient(45deg, #ff6b6b, #4ecdc4); border: none; color: white; padding: 10px 20px; border-radius: 25px; cursor: pointer; font-size: 0.9em; margin: 5px; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); } button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3); } #info { position: absolute; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 10px; max-width: 300px; font-size: 0.9em; } .intersection-point { background: rgba(255, 215, 0, 0.2); padding: 8px; border-radius: 6px; margin: 5px 0; border-left: 3px solid gold; } @media (max-width: 768px) { .container { flex-direction: column; } .controls { width: 100%; height: 50vh; } .viewer { height: 50vh; } } </style> </head> <body> <div class="container"> <div class="controls"> <h1>?? Intersecci√≥n de Planos 3D</h1> <div class="plane-group"> <div class="plane-title"> <div class="color-indicator" style="background-color: #ff6b6b;"></div> Plano 1 (Rojo) </div> <div class="input-group"> <div class="input-label">A</div> <div class="input-label">B</div> <div class="input-label">C</div> <div class="input-label">D</div> </div> <div class="input-group"> <input type="range" id="a1" min="-5" max="5" step="0.1" value="1"> <input type="range" id="b1" min="-5" max="5" step="0.1" value="0"> <input type="range" id="c1" min="-5" max="5" step="0.1" value="0"> <input type="range" id="d1" min="-5" max="5" step="0.1" value="0"> </div> <div class="input-group"> <input type="number" id="a1_num" step="0.1" value="1"> <input type="number" id="b1_num" step="0.1" value="0"> <input type="number" id="c1_num" step="0.1" value="0"> <input type="number" id="d1_num" step="0.1" value="0"> </div> <div class="equation" id="eq1">x + 0y + 0z = 0</div> </div> <div class="plane-group"> <div class="plane-title"> <div class="color-indicator" style="background-color: #4ecdc4;"></div> Plano 2 (Azul) </div> <div class="input-group"> <div class="input-label">A</div> <div class="input-label">B</div> <div class="input-label">C</div> <div class="input-label">D</div> </div> <div class="input-group"> <input type="range" id="a2" min="-5" max="5" step="0.1" value="0"> <input type="range" id="b2" min="-5" max="5" step="0.1" value="1"> <input type="range" id="c2" min="-5" max="5" step="0.1" value="0"> <input type="range" id="d2" min="-5" max="5" step="0.1" value="0"> </div> <div class="input-group"> <input type="number" id="a2_num" step="0.1" value="0"> <input type="number" id="b2_num" step="0.1" value="1"> <input type="number" id="c2_num" step="0.1" value="0"> <input type="number" id="d2_num" step="0.1" value="0"> </div> <div class="equation" id="eq2">0x + y + 0z = 0</div> </div> <div class="plane-group"> <div class="plane-title"> <div class="color-indicator" style="background-color: #95e1d3;"></div> Plano 3 (Verde) </div> <div class="input-group"> <div class="input-label">A</div> <div class="input-label">B</div> <div class="input-label">C</div> <div class="input-label">D</div> </div> <div class="input-group"> <input type="range" id="a3" min="-5" max="5" step="0.1" value="0"> <input type="range" id="b3" min="-5" max="5" step="0.1" value="0"> <input type="range" id="c3" min="-5" max="5" step="0.1" value="1"> <input type="range" id="d3" min="-5" max="5" step="0.1" value="0"> </div> <div class="input-group"> <input type="number" id="a3_num" step="0.1" value="0"> <input type="number" id="b3_num" step="0.1" value="0"> <input type="number" id="c3_num" step="0.1" value="1"> <input type="number" id="d3_num" step="0.1" value="0"> </div> <div class="equation" id="eq3">0x + 0y + z = 0</div> </div> <div class="analysis"> <h3>?? An√°lisis Geom√©trico</h3> <div id="analysis-content"> <p>Los tres planos se intersectan en el punto (0, 0, 0)</p> </div> </div> <div class="controls-bottom"> <button onclick="resetPlanes()">?? Resetear</button> <button onclick="randomize()">?? Aleatorio</button> <button onclick="toggleAnimation()">‚èØÔ∏è Animar</button> </div> </div> <div class="viewer"> <div id="canvas-container"></div> <div id="info"> <h4>?? Controles</h4> <p><strong>Rat√≥n:</strong> Rotar vista</p> <p><strong>Rueda:</strong> Zoom</p> <p><strong>Sliders:</strong> Modificar planos</p> <br> <p><strong>Ecuaci√≥n del plano:</strong><br>Ax + By + Cz = D</p> </div> </div> </div> <script>
        // Variables globales
        let scene, camera, renderer, controls;
        let planes = [];
        let intersectionLines = [];
        let intersectionPoint = null;
        let animationActive = false;
        let animationId;

        // Par√°metros de los planos
        let planeParams = [
            { a: 1, b: 0, c: 0, d: 0 },
            { a: 0, b: 1, c: 0, d: 0 },
            { a: 0, b: 0, c: 1, d: 0 }
        ];

        // Colores de los planos
        const planeColors = [0xff6b6b, 0x4ecdc4, 0x95e1d3];

        // Inicializaci√≥n
        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Configurar c√°mara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 8, 8);

            // Configurar renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth - 320, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controles b√°sicos de rotaci√≥n
            setupBasicControls();

            // Configurar luces
            setupLights();

            // Crear ejes de coordenadas
            createAxes();

            // Crear planos iniciales
            updatePlanes();

            // Configurar event listeners
            setupEventListeners();

            // Iniciar loop de renderizado
            animate();
        }

        function setupBasicControls() {
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let targetRotationX = 0;
            let targetRotationY = 0;
            let currentRotationX = 0;
            let currentRotationY = 0;

            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                const zoomSpeed = 0.1;
                const direction = event.deltaY > 0 ? 1 : -1;
                camera.position.multiplyScalar(1 + direction * zoomSpeed);
                event.preventDefault();
            });

            // Suavizar rotaci√≥n
            function updateRotation() {
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;

                const radius = camera.position.length();
                camera.position.x = radius * Math.sin(currentRotationY) * Math.cos(currentRotationX);
                camera.position.y = radius * Math.sin(currentRotationX);
                camera.position.z = radius * Math.cos(currentRotationY) * Math.cos(currentRotationX);
                camera.lookAt(0, 0, 0);

                requestAnimationFrame(updateRotation);
            }
            updateRotation();
        }

        function setupLights() {
            // Luz ambiental
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Luz direccional
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Luz puntual
            const pointLight = new THREE.PointLight(0x00d4ff, 0.5, 50);
            pointLight.position.set(-10, -10, -10);
            scene.add(pointLight);
        }

        function createAxes() {
            const axesHelper = new THREE.AxesHelper(6);
            scene.add(axesHelper);

            // Etiquetas de ejes
            const loader = new THREE.FontLoader();
            // Como no podemos cargar fuentes externas, usamos geometr√≠a simple para las etiquetas
            const createAxisLabel = (text, position, color) => {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(position);
                scene.add(sphere);
            };

            createAxisLabel('X', new THREE.Vector3(6.5, 0, 0), 0xff0000);
            createAxisLabel('Y', new THREE.Vector3(0, 6.5, 0), 0x00ff00);
            createAxisLabel('Z', new THREE.Vector3(0, 0, 6.5), 0x0000ff);
        }

        function createPlane(a, b, c, d, color, opacity = 0.6) {
            const size = 10;
            const geometry = new THREE.PlaneGeometry(size, size);
            const material = new THREE.MeshLambertMaterial({
                color: color,
                transparent: true,
                opacity: opacity,
                side: THREE.DoubleSide
            });

            const plane = new THREE.Mesh(geometry, material);

            // Posicionar y orientar el plano seg√∫n la ecuaci√≥n Ax + By + Cz = D
            const normal = new THREE.Vector3(a, b, c).normalize();
            const distance = Math.abs(d) / Math.sqrt(a*a + b*b + c*c);

            // Orientar el plano perpendicular al vector normal
            plane.lookAt(normal);
            
            // Posicionar el plano a la distancia correcta del origen
            plane.position.copy(normal.multiplyScalar(d / Math.sqrt(a*a + b*b + c*c)));

            return plane;
        }

        function updatePlanes() {
            // Limpiar planos existentes
            planes.forEach(plane => scene.remove(plane));
            planes = [];

            // Limpiar l√≠neas de intersecci√≥n existentes
            intersectionLines.forEach(line => scene.remove(line));
            intersectionLines = [];

            // Limpiar punto de intersecci√≥n
            if (intersectionPoint) {
                scene.remove(intersectionPoint);
                intersectionPoint = null;
            }

            // Crear nuevos planos
            for (let i = 0; i < 3; i++) {
                const { a, b, c, d } = planeParams[i];
                if (a !== 0 || b !== 0 || c !== 0) {
                    const plane = createPlane(a, b, c, d, planeColors[i]);
                    planes.push(plane);
                    scene.add(plane);
                }
            }

            // Encontrar intersecciones
            findIntersections();
            
            // Actualizar an√°lisis
            updateAnalysis();
        }

        function findIntersections() {
            const [p1, p2, p3] = planeParams;

            // Calcular intersecci√≥n de los tres planos (si existe)
            const det = p1.a * (p2.b * p3.c - p2.c * p3.b) - 
                       p1.b * (p2.a * p3.c - p2.c * p3.a) + 
                       p1.c * (p2.a * p3.b - p2.b * p3.a);

            if (Math.abs(det) > 0.001) {
                // Los tres planos se intersectan en un punto
                const x = (p1.d * (p2.b * p3.c - p2.c * p3.b) - 
                          p1.b * (p2.d * p3.c - p2.c * p3.d) + 
                          p1.c * (p2.d * p3.b - p2.b * p3.d)) / det;
                
                const y = (p1.a * (p2.d * p3.c - p2.c * p3.d) - 
                          p1.d * (p2.a * p3.c - p2.c * p3.a) + 
                          p1.c * (p2.a * p3.d - p2.d * p3.a)) / det;
                
                const z = (p1.a * (p2.b * p3.d - p2.d * p3.b) - 
                          p1.b * (p2.a * p3.d - p2.d * p3.a) + 
                          p1.d * (p2.a * p3.b - p2.b * p3.a)) / det;

                // Crear punto de intersecci√≥n
                const geometry = new THREE.SphereGeometry(0.2, 16, 16);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0x444400
                });
                intersectionPoint = new THREE.Mesh(geometry, material);
                intersectionPoint.position.set(x, y, z);
                scene.add(intersectionPoint);
            }

            // Calcular l√≠neas de intersecci√≥n entre pares de planos
            calculatePairwiseIntersections();
        }

        function calculatePairwiseIntersections() {
            const pairs = [[0, 1], [0, 2], [1, 2]];
            const lineColors = [0xffffff, 0xffff00, 0xff00ff];

            pairs.forEach((pair, index) => {
                const [i, j] = pair;
                const p1 = planeParams[i];
                const p2 = planeParams[j];

                // Calcular direcci√≥n de la l√≠nea de intersecci√≥n
                const direction = new THREE.Vector3(
                    p1.b * p2.c - p1.c * p2.b,
                    p1.c * p2.a - p1.a * p2.c,
                    p1.a * p2.b - p1.b * p2.a
                );

                if (direction.length() > 0.001) {
                    direction.normalize();

                    // Encontrar un punto en la l√≠nea
                    let point = new THREE.Vector3();
                    
                    // Resolver el sistema para encontrar un punto espec√≠fico
                    if (Math.abs(p1.a) > 0.001 || Math.abs(p2.a) > 0.001) {
                        point.y = 0;
                        point.z = 0;
                        if (Math.abs(p1.a) > 0.001) {
                            point.x = p1.d / p1.a;
                        } else {
                            point.x = p2.d / p2.a;
                        }
                    } else if (Math.abs(p1.b) > 0.001 || Math.abs(p2.b) > 0.001) {
                        point.x = 0;
                        point.z = 0;
                        if (Math.abs(p1.b) > 0.001) {
                            point.y = p1.d / p1.b;
                        } else {
                            point.y = p2.d / p2.b;
                        }
                    } else {
                        point.x = 0;
                        point.y = 0;
                        if (Math.abs(p1.c) > 0.001) {
                            point.z = p1.d / p1.c;
                        } else {
                            point.z = p2.d / p2.c;
                        }
                    }

                    // Crear l√≠nea de intersecci√≥n
                    const points = [];
                    const lineLength = 12;
                    for (let t = -lineLength; t <= lineLength; t += 0.5) {
                        const linePoint = point.clone().add(direction.clone().multiplyScalar(t));
                        points.push(linePoint);
                    }

                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ 
                        color: lineColors[index],
                        linewidth: 3
                    });
                    const line = new THREE.Line(geometry, material);
                    intersectionLines.push(line);
                    scene.add(line);
                }
            });
        }

        function updateAnalysis() {
            const analysisElement = document.getElementById('analysis-content');
            let analysisText = '';

            const [p1, p2, p3] = planeParams;

            // Verificar si los planos son paralelos o coincidentes
            const normal1 = new THREE.Vector3(p1.a, p1.b, p1.c);
            const normal2 = new THREE.Vector3(p2.a, p2.b, p2.c);
            const normal3 = new THREE.Vector3(p3.a, p3.b, p3.c);

            const det = p1.a * (p2.b * p3.c - p2.c * p3.b) - 
                       p1.b * (p2.a * p3.c - p2.c * p3.a) + 
                       p1.c * (p2.a * p3.b - p2.b * p3.a);

            if (Math.abs(det) < 0.001) {
                analysisText = '<p style="color: #ff6b6b;">‚ö†Ô∏è Los planos no se intersectan en un punto √∫nico.</p>';
                
                // Verificar si algunos planos son paralelos
                const cross12 = normal1.clone().cross(normal2);
                const cross13 = normal1.clone().cross(normal3);
                const cross23 = normal2.clone().cross(normal3);

                if (cross12.length() < 0.001) {
                    analysisText += '<p>‚Ä¢ Planos 1 y 2 son paralelos o coincidentes</p>';
                }
                if (cross13.length() < 0.001) {
                    analysisText += '<p>‚Ä¢ Planos 1 y 3 son paralelos o coincidentes</p>';
                }
                if (cross23.length() < 0.001) {
                    analysisText += '<p>‚Ä¢ Planos 2 y 3 son paralelos o coincidentes</p>';
                }
            } else {
                const x = (p1.d * (p2.b * p3.c - p2.c * p3.b) - 
                          p1.b * (p2.d * p3.c - p2.c * p3.d) + 
                          p1.c * (p2.d * p3.b - p2.b * p3.d)) / det;
                
                const y = (p1.a * (p2.d * p3.c - p2.c * p3.d) - 
                          p1.d * (p2.a * p3.c - p2.c * p3.a) + 
                          p1.c * (p2.a * p3.d - p2.d * p3.a)) / det;
                
                const z = (p1.a * (p2.b * p3.d - p2.d * p3.b) - 
                          p1.b * (p2.a * p3.d - p2.d * p3.a) + 
                          p1.d * (p2.a * p3.b - p2.b * p3.a)) / det;

                analysisText = `
                    <div class="intersection-point">
                        <strong>‚ú® Punto de intersecci√≥n:</strong><br>
                        (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})
                    </div>
                    <p>‚úÖ Los tres planos se intersectan en un punto √∫nico.</p>
                `;
            }

            analysisElement.innerHTML = analysisText;
        }

        function setupEventListeners() {
            // Event listeners para sliders y campos num√©ricos
            for (let i = 1; i <= 3; i++) {
                ['a', 'b', 'c', 'd'].forEach(param => {
                    const slider = document.getElementById(`${param}${i}`);
                    const numberInput = document.getElementById(`${param}${i}_num`);

                    slider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        numberInput.value = value;
                        planeParams[i-1][param] = value;
                        updateEquation(i);
                        updatePlanes();
                    });

                    numberInput.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value) || 0;
                        slider.value = value;
                        planeParams[i-1][param] = value;
                        updateEquation(i);
                        updatePlanes();
                    });
                });
            }

            // Redimensionar canvas
            window.addEventListener('resize', onWindowResize);
        }

        function updateEquation(planeIndex) {
            const params = planeParams[planeIndex - 1];
            const equation = `${formatCoeff(params.a, 'x')} ${formatCoeff(params.b, 'y', true)} ${formatCoeff(params.c, 'z', true)} = ${params.d}`;
            document.getElementById(`eq${planeIndex}`).textContent = equation;
        }

        function formatCoeff(coeff, variable, showSign = false) {
            if (coeff === 0) return showSign ? '' : `0${variable}`;
            
            const sign = coeff > 0 ? (showSign ? '+ ' : '') : '- ';
            const absCoeff = Math.abs(coeff);
            const coeffStr = absCoeff === 1 ? '' : absCoeff.toString();
            
            return `${sign}${coeffStr}${variable}`;
        }

        function resetPlanes() {
            planeParams = [
                { a: 1, b: 0, c: 0, d: 0 },
                { a: 0, b: 1, c: 0, d: 0 },
                { a: 0, b: 0, c: 1, d: 0 }
            ];
            
            updateInputs();
            updatePlanes();
        }

        function randomize() {
            for (let i = 0; i < 3; i++) {
                planeParams[i] = {
                    a: (Math.random() - 0.5) * 4,
                    b: (Math.random() - 0.5) * 4,
                    c: (Math.random() - 0.5) * 4,
                    d: (Math.random() - 0.5) * 4
                };
            }
            
            updateInputs();
            updatePlanes();
        }

        function updateInputs() {
            for (let i = 0; i < 3; i++) {
                ['a', 'b', 'c', 'd'].forEach(param => {
                    const value = planeParams[i][param];
                    document.getElementById(`${param}${i+1}`).value = value;
                    document.getElementById(`${param}${i+1}_num`).value = value.toFixed(1);
                });
                updateEquation(i + 1);
            }
        }

        function toggleAnimation() {
            animationActive = !animationActive;
            if (animationActive) {
                startAnimation();
            } else {
                stopAnimation();
            }
        }

        function startAnimation() {
            let time = 0;
            
            function animateStep() {
                if (!animationActive) return;
                
                time += 0.02;
                
                // Animar los par√°metros de los planos
                for (let i = 0; i < 3; i++) {
                    planeParams[i].d = 2 * Math.sin(time + i * Math.PI / 3);
                }
                
                updateInputs();
                updatePlanes();
                
                animationId = requestAnimationFrame(animateStep);
            }
            
            animateStep();
        }

        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const width = window.innerWidth - 320;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // Inicializar ecuaciones
        function initializeEquations() {
            for (let i = 1; i <= 3; i++) {
                updateEquation(i);
            }
        }

        // Iniciar aplicaci√≥n
        init();
        initializeEquations();

        // Configuraciones predefinidas
        function loadPreset(preset) {
            switch(preset) {
                case 'orthogonal':
                    planeParams = [
                        { a: 1, b: 0, c: 0, d: 0 },
                        { a: 0, b: 1, c: 0, d: 0 },
                        { a: 0, b: 0, c: 1, d: 0 }
                    ];
                    break;
                case 'parallel':
                    planeParams = [
                        { a: 1, b: 0, c: 0, d: 0 },
                        { a: 1, b: 0, c: 0, d: 2 },
                        { a: 0, b: 1, c: 0, d: 0 }
                    ];
                    break;
                case 'intersecting':
                    planeParams = [
                        { a: 1, b: 1, c: 0, d: 0 },
                        { a: 1, b: 0, c: 1, d: 0 },
                        { a: 0, b: 1, c: 1, d: 0 }
                    ];
                    break;
            }
            updateInputs();
            updatePlanes();
        }

        // Exportar configuraci√≥n
        function exportConfig() {
            const config = {
                planes: planeParams,
                timestamp: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(config, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'plane_intersection_config.json';
            link.click();
        }

        // Importar configuraci√≥n
        function importConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const config = JSON.parse(e.target.result);
                            if (config.planes) {
                                planeParams = config.planes;
                                updateInputs();
                                updatePlanes();
                            }
                        } catch (error) {
                            alert('Error al cargar el archivo de configuraci√≥n');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            
            input.click();
        }

        // Agregar botones adicionales
        document.querySelector('.controls-bottom').innerHTML += `
            <button onclick="loadPreset('orthogonal')">üìê Ortogonales</button>
            <button onclick="loadPreset('parallel')">üìè Paralelos</button>
            <button onclick="loadPreset('intersecting')">üîó Intersecci√≥n</button>
            <button onclick="exportConfig()">üíæ Exportar</button>
            <button onclick="importConfig()">üìÇ Importar</button>
        `;

        // Informaci√≥n adicional sobre casos especiales
        function addSpecialCasesInfo() {
            const infoDiv = document.getElementById('info');
            infoDiv.innerHTML += `
                <br>
                <h4>üîç Casos Especiales</h4>
                <p><strong>Punto √∫nico:</strong> Los 3 planos se cortan en 1 punto</p>
                <p><strong>L√≠nea:</strong> Los 3 planos se cortan en una l√≠nea</p>
                <p><strong>Paralelos:</strong> No hay intersecci√≥n</p>
                <p><strong>Coincidentes:</strong> Infinitas soluciones</p>
            `;
        }

        addSpecialCasesInfo();
    </script> </body> </html> 